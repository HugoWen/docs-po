# 
msgid ""
msgstr ""
"Project-Id-Version: Symfony Framework Documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-03-24 10:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../book/http_cache.rst:5
msgid "HTTP Cache"
msgstr ""

#: ../../book/http_cache.rst:7
msgid ""
"The nature of rich web applications means that they're dynamic. No matter "
"how efficient your application, each request will always contain more "
"overhead than serving a static file."
msgstr ""

#: ../../book/http_cache.rst:11
msgid ""
"And for most Web applications, that's fine. Symfony is lightning fast, and "
"unless you're doing some serious heavy-lifting, each request will come back "
"quickly without putting too much stress on your server."
msgstr ""

#: ../../book/http_cache.rst:15
msgid ""
"But as your site grows, that overhead can become a problem. The processing "
"that's normally performed on every request should be done only once. This is"
" exactly what caching aims to accomplish."
msgstr ""

#: ../../book/http_cache.rst:20
msgid "Caching on the Shoulders of Giants"
msgstr ""

#: ../../book/http_cache.rst:22
msgid ""
"The most effective way to improve performance of an application is to cache "
"the full output of a page and then bypass the application entirely on each "
"subsequent request. Of course, this isn't always possible for highly dynamic"
" websites, or is it? In this chapter, you'll see how the Symfony cache "
"system works and why this is the best possible approach."
msgstr ""

#: ../../book/http_cache.rst:28
msgid ""
"The Symfony cache system is different because it relies on the simplicity "
"and power of the HTTP cache as defined in the :term:`HTTP specification`. "
"Instead of reinventing a caching methodology, Symfony embraces the standard "
"that defines basic communication on the Web. Once you understand the "
"fundamental HTTP validation and expiration caching models, you'll be ready "
"to master the Symfony cache system."
msgstr ""

#: ../../book/http_cache.rst:35
msgid ""
"For the purposes of learning how to cache with Symfony, the subject is "
"covered in four steps:"
msgstr ""

#: ../../book/http_cache.rst:38
msgid ""
"A :ref:`gateway cache <gateway-caches>`, or reverse proxy, is an independent"
" layer that sits in front of your application. The reverse proxy caches "
"responses as they're returned from your application and answers requests "
"with cached responses before they hit your application. Symfony provides its"
" own reverse proxy, but any reverse proxy can be used."
msgstr ""

#: ../../book/http_cache.rst:44
msgid ""
":ref:`HTTP cache <http-cache-introduction>` headers are used to communicate "
"with the gateway cache and any other caches between your application and the"
" client. Symfony provides sensible defaults and a powerful interface for "
"interacting with the cache headers."
msgstr ""

#: ../../book/http_cache.rst:49
msgid ""
"HTTP :ref:`expiration and validation <http-expiration-validation>` are the "
"two models used for determining whether cached content is *fresh* (can be "
"reused from the cache) or *stale* (should be regenerated by the "
"application)."
msgstr ""

#: ../../book/http_cache.rst:54
msgid ""
":ref:`Edge Side Includes <edge-side-includes>` (ESI) allow HTTP cache to be "
"used to cache page fragments (even nested fragments) independently. With "
"ESI, you can even cache an entire page for 60 minutes, but an embedded "
"sidebar for only 5 minutes."
msgstr ""

#: ../../book/http_cache.rst:59
msgid ""
"Since caching with HTTP isn't unique to Symfony, many articles already exist"
" on the topic. If you're new to HTTP caching, Ryan Tomayko's article `Things"
" Caches Do`_ is *highly* recommended . Another in-depth resource is Mark "
"Nottingham's `Cache Tutorial`_."
msgstr ""

#: ../../book/http_cache.rst:72
msgid "Caching with a Gateway Cache"
msgstr ""

#: ../../book/http_cache.rst:74
msgid ""
"When caching with HTTP, the *cache* is separated from your application "
"entirely and sits between your application and the client making the "
"request."
msgstr ""

#: ../../book/http_cache.rst:77
msgid ""
"The job of the cache is to accept requests from the client and pass them "
"back to your application. The cache will also receive responses back from "
"your application and forward them on to the client. The cache is the "
"\"middle-man\" of the request-response communication between the client and "
"your application."
msgstr ""

#: ../../book/http_cache.rst:82
msgid ""
"Along the way, the cache will store each response that is deemed "
"\"cacheable\" (See :ref:`http-cache-introduction`). If the same resource is "
"requested again, the cache sends the cached response to the client, ignoring"
" your application entirely."
msgstr ""

#: ../../book/http_cache.rst:87
msgid ""
"This type of cache is known as a HTTP gateway cache and many exist such as "
"`Varnish`_, `Squid in reverse proxy mode`_, and the Symfony reverse proxy."
msgstr ""

#: ../../book/http_cache.rst:94
msgid "Types of Caches"
msgstr ""

#: ../../book/http_cache.rst:96
msgid ""
"But a gateway cache isn't the only type of cache. In fact, the HTTP cache "
"headers sent by your application are consumed and interpreted by up to three"
" different types of caches:"
msgstr ""

#: ../../book/http_cache.rst:100
msgid ""
"*Browser caches*: Every browser comes with its own local cache that is "
"mainly useful for when you hit \"back\" or for images and other assets. The "
"browser cache is a *private* cache as cached resources aren't shared with "
"anyone else;"
msgstr ""

#: ../../book/http_cache.rst:105
msgid ""
"*Proxy caches*: A proxy is a *shared* cache as many people can be behind a "
"single one. It's usually installed by large corporations and ISPs to reduce "
"latency and network traffic;"
msgstr ""

#: ../../book/http_cache.rst:109
msgid ""
"*Gateway caches*: Like a proxy, it's also a *shared* cache but on the server"
" side. Installed by network administrators, it makes websites more scalable,"
" reliable and performant."
msgstr ""

#: ../../book/http_cache.rst:115
msgid ""
"Gateway caches are sometimes referred to as reverse proxy caches, surrogate "
"caches, or even HTTP accelerators."
msgstr ""

#: ../../book/http_cache.rst:120
msgid ""
"The significance of *private* versus *shared* caches will become more "
"obvious when caching responses containing content that is specific to "
"exactly one user (e.g. account information) is discussed."
msgstr ""

#: ../../book/http_cache.rst:124
msgid ""
"Each response from your application will likely go through one or both of "
"the first two cache types. These caches are outside of your control but "
"follow the HTTP cache directions set in the response."
msgstr ""

#: ../../book/http_cache.rst:135
msgid "Symfony Reverse Proxy"
msgstr ""

#: ../../book/http_cache.rst:137
msgid ""
"Symfony comes with a reverse proxy (also called a gateway cache) written in "
"PHP. Enable it and cacheable responses from your application will start to "
"be cached right away. Installing it is just as easy. Each new Symfony "
"application comes with a pre-configured caching kernel (``AppCache``) that "
"wraps the default one (``AppKernel``). The caching Kernel *is* the reverse "
"proxy."
msgstr ""

#: ../../book/http_cache.rst:144
msgid ""
"To enable caching, modify the code of a front controller to use the caching "
"kernel::"
msgstr ""

#: ../../book/http_cache.rst:166
msgid ""
"The caching kernel will immediately act as a reverse proxy - caching "
"responses from your application and returning them to the client."
msgstr ""

#: ../../book/http_cache.rst:171
msgid ""
"If you're using the :ref:`framework.http_method_override <configuration-"
"framework-http_method_override>` option to read the HTTP method from a "
"``_method`` parameter, see the above link for a tweak you need to make."
msgstr ""

#: ../../book/http_cache.rst:177
msgid ""
"The cache kernel has a special ``getLog()`` method that returns a string "
"representation of what happened in the cache layer. In the development "
"environment, use it to debug and validate your cache strategy::"
msgstr ""

#: ../../book/http_cache.rst:183
msgid ""
"The ``AppCache`` object has a sensible default configuration, but it can be "
"finely tuned via a set of options you can set by overriding the "
":method:`Symfony\\\\Bundle\\\\FrameworkBundle\\\\HttpCache\\\\HttpCache::getOptions`"
" method::"
msgstr ""

#: ../../book/http_cache.rst:209
msgid ""
"Unless overridden in ``getOptions()``, the ``debug`` option will be set to "
"automatically be the debug value of the wrapped ``AppKernel``."
msgstr ""

#: ../../book/http_cache.rst:212
msgid "Here is a list of the main options:"
msgstr ""

#: ../../book/http_cache.rst:217
msgid "``default_ttl``"
msgstr ""

#: ../../book/http_cache.rst:215
msgid ""
"The number of seconds that a cache entry should be considered fresh when no "
"explicit freshness information is provided in a response. Explicit ``Cache-"
"Control`` or ``Expires`` headers override this value (default: ``0``)."
msgstr ""

#: ../../book/http_cache.rst:223
msgid "``private_headers``"
msgstr ""

#: ../../book/http_cache.rst:220
msgid ""
"Set of request headers that trigger \"private\" ``Cache-Control`` behavior "
"on responses that don't explicitly state whether the response is ``public`` "
"or ``private`` via a ``Cache-Control`` directive (default: ``Authorization``"
" and ``Cookie``)."
msgstr ""

#: ../../book/http_cache.rst:228
msgid "``allow_reload``"
msgstr ""

#: ../../book/http_cache.rst:226
msgid ""
"Specifies whether the client can force a cache reload by including a "
"``Cache-Control`` \"no-cache\" directive in the request. Set it to ``true`` "
"for compliance with RFC 2616 (default: ``false``)."
msgstr ""

#: ../../book/http_cache.rst:233
msgid "``allow_revalidate``"
msgstr ""

#: ../../book/http_cache.rst:231
msgid ""
"Specifies whether the client can force a cache revalidate by including a "
"``Cache-Control`` \"max-age=0\" directive in the request. Set it to ``true``"
" for compliance with RFC 2616 (default: false)."
msgstr ""

#: ../../book/http_cache.rst:240
msgid "``stale_while_revalidate``"
msgstr ""

#: ../../book/http_cache.rst:236
msgid ""
"Specifies the default number of seconds (the granularity is the second as "
"the Response TTL precision is a second) during which the cache can "
"immediately return a stale response while it revalidates it in the "
"background (default: ``2``); this setting is overridden by the ``stale-"
"while-revalidate`` HTTP ``Cache-Control`` extension (see RFC 5861)."
msgstr ""

#: ../../book/http_cache.rst:246
msgid "``stale_if_error``"
msgstr ""

#: ../../book/http_cache.rst:243
msgid ""
"Specifies the default number of seconds (the granularity is the second) "
"during which the cache can serve a stale response when an error is "
"encountered (default: ``60``). This setting is overridden by the ``stale-if-"
"error`` HTTP ``Cache-Control`` extension (see RFC 5861)."
msgstr ""

#: ../../book/http_cache.rst:248
msgid ""
"If ``debug`` is ``true``, Symfony automatically adds an ``X-Symfony-Cache`` "
"header to the response containing useful information about cache hits and "
"misses."
msgstr ""

#: ../../book/http_cache.rst:0
msgid "Changing from one Reverse Proxy to another"
msgstr ""

#: ../../book/http_cache.rst:254
msgid ""
"The Symfony reverse proxy is a great tool to use when developing your "
"website or when you deploy your website to a shared host where you cannot "
"install anything beyond PHP code. But being written in PHP, it cannot be as "
"fast as a proxy written in C. That's why it is highly recommended you use "
"Varnish or Squid on your production servers if possible. The good news is "
"that the switch from one proxy server to another is easy and transparent as "
"no code modification is needed in your application. Start easy with the "
"Symfony reverse proxy and upgrade later to Varnish when your traffic "
"increases."
msgstr ""

#: ../../book/http_cache.rst:264
msgid ""
"For more information on using Varnish with Symfony, see the :doc:`How to use"
" Varnish </cookbook/cache/varnish>` cookbook chapter."
msgstr ""

#: ../../book/http_cache.rst:269
msgid ""
"The performance of the Symfony reverse proxy is independent of the "
"complexity of the application. That's because the application kernel is only"
" booted when the request needs to be forwarded to it."
msgstr ""

#: ../../book/http_cache.rst:279
msgid "Introduction to HTTP Caching"
msgstr ""

#: ../../book/http_cache.rst:281
msgid ""
"To take advantage of the available cache layers, your application must be "
"able to communicate which responses are cacheable and the rules that govern "
"when/how that cache should become stale. This is done by setting HTTP cache "
"headers on the response."
msgstr ""

#: ../../book/http_cache.rst:288
msgid ""
"Keep in mind that \"HTTP\" is nothing more than the language (a simple text "
"language) that web clients (e.g. browsers) and web servers use to "
"communicate with each other. HTTP caching is the part of that language that "
"allows clients and servers to exchange information related to caching."
msgstr ""

#: ../../book/http_cache.rst:293
msgid "HTTP specifies four response cache headers that are looked at here:"
msgstr ""

#: ../../book/http_cache.rst:295
msgid "``Cache-Control``"
msgstr ""

#: ../../book/http_cache.rst:296
msgid "``Expires``"
msgstr ""

#: ../../book/http_cache.rst:297
msgid "``ETag``"
msgstr ""

#: ../../book/http_cache.rst:298
msgid "``Last-Modified``"
msgstr ""

#: ../../book/http_cache.rst:300
msgid ""
"The most important and versatile header is the ``Cache-Control`` header, "
"which is actually a collection of various cache information."
msgstr ""

#: ../../book/http_cache.rst:305
msgid ""
"Each of the headers will be explained in full detail in the :ref:`http-"
"expiration-validation` section."
msgstr ""

#: ../../book/http_cache.rst:313
msgid "The Cache-Control Header"
msgstr ""

#: ../../book/http_cache.rst:315
msgid ""
"The ``Cache-Control`` header is unique in that it contains not one, but "
"various pieces of information about the cacheability of a response. Each "
"piece of information is separated by a comma:"
msgstr ""

#: ../../book/http_cache.rst:325
msgid ""
"Symfony provides an abstraction around the ``Cache-Control`` header to make "
"its creation more manageable::"
msgstr ""

#: ../../book/http_cache.rst:347
msgid ""
"If you need to set cache headers for many different controller actions, you "
"might want to look into the FOSHttpCacheBundle_. It provides a way to define"
" cache headers based on the URL pattern and other request properties."
msgstr ""

#: ../../book/http_cache.rst:353
msgid "Public vs Private Responses"
msgstr ""

#: ../../book/http_cache.rst:355
msgid ""
"Both gateway and proxy caches are considered \"shared\" caches as the cached"
" content is shared by more than one user. If a user-specific response were "
"ever mistakenly stored by a shared cache, it might be returned later to any "
"number of different users. Imagine if your account information were cached "
"and then returned to every subsequent user who asked for their account page!"
msgstr ""

#: ../../book/http_cache.rst:361
msgid ""
"To handle this situation, every response may be set to be public or private:"
msgstr ""

#: ../../book/http_cache.rst:364
msgid "*public*"
msgstr ""

#: ../../book/http_cache.rst:364
msgid ""
"Indicates that the response may be cached by both private and shared caches."
msgstr ""

#: ../../book/http_cache.rst:368
msgid "*private*"
msgstr ""

#: ../../book/http_cache.rst:367
msgid ""
"Indicates that all or part of the response message is intended for a single "
"user and must not be cached by a shared cache."
msgstr ""

#: ../../book/http_cache.rst:370
msgid ""
"Symfony conservatively defaults each response to be private. To take "
"advantage of shared caches (like the Symfony reverse proxy), the response "
"will need to be explicitly set as public."
msgstr ""

#: ../../book/http_cache.rst:378
msgid "Safe Methods"
msgstr ""

#: ../../book/http_cache.rst:380
msgid ""
"HTTP caching only works for \"safe\" HTTP methods (like GET and HEAD). Being"
" safe means that you never change the application's state on the server when"
" serving the request (you can of course log information, cache data, etc). "
"This has two very reasonable consequences:"
msgstr ""

#: ../../book/http_cache.rst:385
msgid ""
"You should *never* change the state of your application when responding to a"
" GET or HEAD request. Even if you don't use a gateway cache, the presence of"
" proxy caches mean that any GET or HEAD request may or may not actually hit "
"your server;"
msgstr ""

#: ../../book/http_cache.rst:390
msgid ""
"Don't expect PUT, POST or DELETE methods to cache. These methods are meant "
"to be used when mutating the state of your application (e.g. deleting a blog"
" post). Caching them would prevent certain requests from hitting and "
"mutating your application."
msgstr ""

#: ../../book/http_cache.rst:398
msgid "Caching Rules and Defaults"
msgstr ""

#: ../../book/http_cache.rst:400
msgid ""
"HTTP 1.1 allows caching anything by default unless there is an explicit "
"``Cache-Control`` header. In practice, most caches do nothing when requests "
"have a cookie, an authorization header, use a non-safe method (i.e. PUT, "
"POST, DELETE), or when responses have a redirect status code."
msgstr ""

#: ../../book/http_cache.rst:405
msgid ""
"Symfony automatically sets a sensible and conservative ``Cache-Control`` "
"header when none is set by the developer by following these rules:"
msgstr ""

#: ../../book/http_cache.rst:408
msgid ""
"If no cache header is defined (``Cache-Control``, ``Expires``, ``ETag`` or "
"``Last-Modified``), ``Cache-Control`` is set to ``no-cache``, meaning that "
"the response will not be cached;"
msgstr ""

#: ../../book/http_cache.rst:412
msgid ""
"If ``Cache-Control`` is empty (but one of the other cache headers is "
"present), its value is set to ``private, must-revalidate``;"
msgstr ""

#: ../../book/http_cache.rst:415
msgid ""
"But if at least one ``Cache-Control`` directive is set, and no ``public`` or"
" ``private`` directives have been explicitly added, Symfony adds the "
"``private`` directive automatically (except when ``s-maxage`` is set)."
msgstr ""

#: ../../book/http_cache.rst:423
msgid "HTTP Expiration, Validation and Invalidation"
msgstr ""

#: ../../book/http_cache.rst:425
msgid "The HTTP specification defines two caching models:"
msgstr ""

#: ../../book/http_cache.rst:427
msgid ""
"With the `expiration model`_, you simply specify how long a response should "
"be considered \"fresh\" by including a ``Cache-Control`` and/or an "
"``Expires`` header. Caches that understand expiration will not make the same"
" request until the cached version reaches its expiration time and becomes "
"\"stale\";"
msgstr ""

#: ../../book/http_cache.rst:432
msgid ""
"When pages are really dynamic (i.e. their representation changes often), the"
" `validation model`_ is often necessary. With this model, the cache stores "
"the response, but asks the server on each request whether or not the cached "
"response is still valid. The application uses a unique response identifier "
"(the ``Etag`` header) and/or a timestamp (the ``Last-Modified`` header) to "
"check if the page has changed since being cached."
msgstr ""

#: ../../book/http_cache.rst:439
msgid ""
"The goal of both models is to never generate the same response twice by "
"relying on a cache to store and return \"fresh\" responses. To achieve long "
"caching times but still provide updated content immediately, *cache "
"invalidation* is sometimes used."
msgstr ""

#: ../../book/http_cache.rst:0
msgid "Reading the HTTP Specification"
msgstr ""

#: ../../book/http_cache.rst:446
msgid ""
"The HTTP specification defines a simple but powerful language in which "
"clients and servers can communicate. As a web developer, the request-"
"response model of the specification dominates your work. Unfortunately, the "
"actual specification document - `RFC 2616`_ - can be difficult to read."
msgstr ""

#: ../../book/http_cache.rst:451
msgid ""
"There is an ongoing effort (`HTTP Bis`_) to rewrite the RFC 2616. It does "
"not describe a new version of HTTP, but mostly clarifies the original HTTP "
"specification. The organization is also improved as the specification is "
"split into seven parts; everything related to HTTP caching can be found in "
"two dedicated parts (`P4 - Conditional Requests`_ and `P6 - Caching: Browser"
" and intermediary caches`_)."
msgstr ""

#: ../../book/http_cache.rst:458
msgid ""
"As a web developer, you are strongly urged to read the specification. Its "
"clarity and power - even more than ten years after its creation - is "
"invaluable. Don't be put-off by the appearance of the spec - its contents "
"are much more beautiful than its cover."
msgstr ""

#: ../../book/http_cache.rst:467
msgid "Expiration"
msgstr ""

#: ../../book/http_cache.rst:469
msgid ""
"The expiration model is the more efficient and straightforward of the two "
"caching models and should be used whenever possible. When a response is "
"cached with an expiration, the cache will store the response and return it "
"directly without hitting the application until it expires."
msgstr ""

#: ../../book/http_cache.rst:474
msgid ""
"The expiration model can be accomplished using one of two, nearly identical,"
" HTTP headers: ``Expires`` or ``Cache-Control``."
msgstr ""

#: ../../book/http_cache.rst:482
msgid "Expiration with the ``Expires`` Header"
msgstr ""

#: ../../book/http_cache.rst:484
msgid ""
"According to the HTTP specification, \"the ``Expires`` header field gives "
"the date/time after which the response is considered stale.\" The "
"``Expires`` header can be set with the ``setExpires()`` ``Response`` method."
" It takes a ``DateTime`` instance as an argument::"
msgstr ""

#: ../../book/http_cache.rst:494
msgid "The resulting HTTP header will look like this:"
msgstr ""

#: ../../book/http_cache.rst:502
msgid ""
"The ``setExpires()`` method automatically converts the date to the GMT "
"timezone as required by the specification."
msgstr ""

#: ../../book/http_cache.rst:505
msgid ""
"Note that in HTTP versions before 1.1 the origin server wasn't required to "
"send the ``Date`` header. Consequently, the cache (e.g. the browser) might "
"need to rely on the local clock to evaluate the ``Expires`` header making "
"the lifetime calculation vulnerable to clock skew. Another limitation of the"
" ``Expires`` header is that the specification states that \"HTTP/1.1 servers"
" should not send ``Expires`` dates more than one year in the future.\""
msgstr ""

#: ../../book/http_cache.rst:517
msgid "Expiration with the ``Cache-Control`` Header"
msgstr ""

#: ../../book/http_cache.rst:519
msgid ""
"Because of the ``Expires`` header limitations, most of the time, you should "
"use the ``Cache-Control`` header instead. Recall that the ``Cache-Control`` "
"header is used to specify many different cache directives. For expiration, "
"there are two directives, ``max-age`` and ``s-maxage``. The first one is "
"used by all caches, whereas the second one is only taken into account by "
"shared caches::"
msgstr ""

#: ../../book/http_cache.rst:533
msgid ""
"The ``Cache-Control`` header would take on the following format (it may have"
" additional directives):"
msgstr ""

#: ../../book/http_cache.rst:544 ../../book/http_cache.rst:540
msgid "Validation"
msgstr ""

#: ../../book/http_cache.rst:546
msgid ""
"When a resource needs to be updated as soon as a change is made to the "
"underlying data, the expiration model falls short. With the expiration "
"model, the application won't be asked to return the updated response until "
"the cache finally becomes stale."
msgstr ""

#: ../../book/http_cache.rst:551
msgid ""
"The validation model addresses this issue. Under this model, the cache "
"continues to store responses. The difference is that, for each request, the "
"cache asks the application if the cached response is still valid or if it "
"needs to be regenerated. If the cache *is* still valid, your application "
"should return a 304 status code and no content. This tells the cache that "
"it's ok to return the cached response."
msgstr ""

#: ../../book/http_cache.rst:557
msgid ""
"Under this model, you only save CPU if you're able to determine that the "
"cached response is still valid by doing *less* work than generating the "
"whole page again (see below for an implementation example)."
msgstr ""

#: ../../book/http_cache.rst:563
msgid ""
"The 304 status code means \"Not Modified\". It's important because with this"
" status code the response does *not* contain the actual content being "
"requested. Instead, the response is simply a light-weight set of directions "
"that tells the cache that it should use its stored version."
msgstr ""

#: ../../book/http_cache.rst:568
msgid ""
"Like with expiration, there are two different HTTP headers that can be used "
"to implement the validation model: ``ETag`` and ``Last-Modified``."
msgstr ""

#: ../../book/http_cache.rst:576
msgid "Validation with the ``ETag`` Header"
msgstr ""

#: ../../book/http_cache.rst:578
msgid ""
"The ``ETag`` header is a string header (called the \"entity-tag\") that "
"uniquely identifies one representation of the target resource. It's entirely"
" generated and set by your application so that you can tell, for example, if"
" the ``/about`` resource that's stored by the cache is up-to-date with what "
"your application would return. An ``ETag`` is like a fingerprint and is used"
" to quickly compare if two different versions of a resource are equivalent. "
"Like fingerprints, each ``ETag`` must be unique across all representations "
"of the same resource."
msgstr ""

#: ../../book/http_cache.rst:586
msgid ""
"To see a simple implementation, generate the ETag as the md5 of the "
"content::"
msgstr ""

#: ../../book/http_cache.rst:606
msgid ""
"The "
":method:`Symfony\\\\Component\\\\HttpFoundation\\\\Response::isNotModified` "
"method compares the ``If-None-Match`` sent with the ``Request`` with the "
"``ETag`` header set on the ``Response``. If the two match, the method "
"automatically sets the ``Response`` status code to 304."
msgstr ""

#: ../../book/http_cache.rst:613
msgid ""
"The cache sets the ``If-None-Match`` header on the request to the ``ETag`` "
"of the original cached response before sending the request back to the app. "
"This is how the cache and server communicate with each other and decide "
"whether or not the resource has been updated since it was cached."
msgstr ""

#: ../../book/http_cache.rst:618
msgid ""
"This algorithm is simple enough and very generic, but you need to create the"
" whole ``Response`` before being able to compute the ETag, which is sub-"
"optimal. In other words, it saves on bandwidth, but not CPU cycles."
msgstr ""

#: ../../book/http_cache.rst:622
msgid ""
"In the :ref:`optimizing-cache-validation` section, you'll see how validation"
" can be used more intelligently to determine the validity of a cache without"
" doing so much work."
msgstr ""

#: ../../book/http_cache.rst:628
msgid ""
"Symfony also supports weak ETags by passing ``true`` as the second argument "
"to the :method:`Symfony\\\\Component\\\\HttpFoundation\\\\Response::setETag`"
" method."
msgstr ""

#: ../../book/http_cache.rst:637
msgid "Validation with the ``Last-Modified`` Header"
msgstr ""

#: ../../book/http_cache.rst:639
msgid ""
"The ``Last-Modified`` header is the second form of validation. According to "
"the HTTP specification, \"The ``Last-Modified`` header field indicates the "
"date and time at which the origin server believes the representation was "
"last modified.\" In other words, the application decides whether or not the "
"cached content has been updated based on whether or not it's been updated "
"since the response was cached."
msgstr ""

#: ../../book/http_cache.rst:646
msgid ""
"For instance, you can use the latest update date for all the objects needed "
"to compute the resource representation as the value for the ``Last-"
"Modified`` header value::"
msgstr ""

#: ../../book/http_cache.rst:682
msgid ""
"The "
":method:`Symfony\\\\Component\\\\HttpFoundation\\\\Response::isNotModified` "
"method compares the ``If-Modified-Since`` header sent by the request with "
"the ``Last-Modified`` header set on the response. If they are equivalent, "
"the ``Response`` will be set to a 304 status code."
msgstr ""

#: ../../book/http_cache.rst:689
msgid ""
"The cache sets the ``If-Modified-Since`` header on the request to the "
"``Last-Modified`` of the original cached response before sending the request"
" back to the app. This is how the cache and server communicate with each "
"other and decide whether or not the resource has been updated since it was "
"cached."
msgstr ""

#: ../../book/http_cache.rst:701
msgid "Optimizing your Code with Validation"
msgstr ""

#: ../../book/http_cache.rst:703
msgid ""
"The main goal of any caching strategy is to lighten the load on the "
"application. Put another way, the less you do in your application to return "
"a 304 response, the better. The ``Response::isNotModified()`` method does "
"exactly that by exposing a simple and efficient pattern::"
msgstr ""

#: ../../book/http_cache.rst:750
msgid ""
"When the ``Response`` is not modified, the ``isNotModified()`` automatically"
" sets the response status code to ``304``, removes the content, and removes "
"some headers that must not be present for ``304`` responses (see "
":method:`Symfony\\\\Component\\\\HttpFoundation\\\\Response::setNotModified`)."
msgstr ""

#: ../../book/http_cache.rst:760
msgid "Varying the Response"
msgstr ""

#: ../../book/http_cache.rst:762
msgid ""
"So far, it's been assumed that each URI has exactly one representation of "
"the target resource. By default, HTTP caching is done by using the URI of "
"the resource as the cache key. If two people request the same URI of a "
"cacheable resource, the second person will receive the cached version."
msgstr ""

#: ../../book/http_cache.rst:767
msgid ""
"Sometimes this isn't enough and different versions of the same URI need to "
"be cached based on one or more request header values. For instance, if you "
"compress pages when the client supports it, any given URI has two "
"representations: one when the client supports compression, and one when it "
"does not. This determination is done by the value of the ``Accept-Encoding``"
" request header."
msgstr ""

#: ../../book/http_cache.rst:773
msgid ""
"In this case, you need the cache to store both a compressed and uncompressed"
" version of the response for the particular URI and return them based on the"
" request's ``Accept-Encoding`` value. This is done by using the ``Vary`` "
"response header, which is a comma-separated list of different headers whose "
"values trigger a different representation of the requested resource:"
msgstr ""

#: ../../book/http_cache.rst:785
msgid ""
"This particular ``Vary`` header would cache different versions of each "
"resource based on the URI and the value of the ``Accept-Encoding`` and "
"``User-Agent`` request header."
msgstr ""

#: ../../book/http_cache.rst:789
msgid ""
"The ``Response`` object offers a clean interface for managing the ``Vary`` "
"header::"
msgstr ""

#: ../../book/http_cache.rst:798
msgid ""
"The ``setVary()`` method takes a header name or an array of header names for"
" which the response varies."
msgstr ""

#: ../../book/http_cache.rst:802
msgid "Expiration and Validation"
msgstr ""

#: ../../book/http_cache.rst:804
msgid ""
"You can of course use both validation and expiration within the same "
"``Response``. As expiration wins over validation, you can easily benefit "
"from the best of both worlds. In other words, by using both expiration and "
"validation, you can instruct the cache to serve the cached content, while "
"checking back at some interval (the expiration) to verify that the content "
"is still valid."
msgstr ""

#: ../../book/http_cache.rst:812
msgid ""
"You can also define HTTP caching headers for expiration and validation by "
"using annotations. See the `FrameworkExtraBundle documentation`_."
msgstr ""

#: ../../book/http_cache.rst:819
msgid "More Response Methods"
msgstr ""

#: ../../book/http_cache.rst:821
msgid ""
"The Response class provides many more methods related to the cache. Here are"
" the most useful ones::"
msgstr ""

#: ../../book/http_cache.rst:830
msgid ""
"Additionally, most cache-related HTTP headers can be set via the single "
":method:`Symfony\\\\Component\\\\HttpFoundation\\\\Response::setCache` "
"method::"
msgstr ""

#: ../../book/http_cache.rst:849
msgid "Cache Invalidation"
msgstr ""

#: ../../book/http_cache.rst:851
msgid ""
"\"There are only two hard things in Computer Science: cache invalidation and"
" naming things.\" -- Phil Karlton"
msgstr ""

#: ../../book/http_cache.rst:854
msgid ""
"Once an URL is cached by a gateway cache, the cache will not ask the "
"application for that content anymore. This allows the cache to provide fast "
"responses and reduces the load on your application. However, you risk "
"delivering outdated content. A way out of this dilemma is to use long cache "
"lifetimes, but to actively notify the gateway cache when content changes. "
"Reverse proxies usually provide a channel to receive such notifications, "
"typically through special HTTP requests."
msgstr ""

#: ../../book/http_cache.rst:864
msgid ""
"While cache invalidation is powerful, avoid it when possible. If you fail to"
" invalidate something, outdated caches will be served for a potentially long"
" time. Instead, use short cache lifetimes or use the validation model, and "
"adjust your controllers to perform efficient validation checks as explained "
"in :ref:`optimizing-cache-validation`."
msgstr ""

#: ../../book/http_cache.rst:870
msgid ""
"Furthermore, since invalidation is a topic specific to each type of reverse "
"proxy, using this concept will tie you to a specific reverse proxy or need "
"additional efforts to support different proxies."
msgstr ""

#: ../../book/http_cache.rst:874
msgid ""
"Sometimes, however, you need that extra performance you can get when "
"explicitly invalidating. For invalidation, your application needs to detect "
"when content changes and tell the cache to remove the URLs which contain "
"that data from its cache."
msgstr ""

#: ../../book/http_cache.rst:881
msgid ""
"If you want to use cache invalidation, have a look at the "
"`FOSHttpCacheBundle`_. This bundle provides services to help with various "
"cache invalidation concepts, and also documents the configuration for the a "
"couple of common caching proxies."
msgstr ""

#: ../../book/http_cache.rst:886
msgid ""
"If one content corresponds to one URL, the ``PURGE`` model works well. You "
"send a request to the cache proxy with the HTTP method ``PURGE`` (using the "
"word \"PURGE\" is a convention, technically this can be any string) instead "
"of ``GET`` and make the cache proxy detect this and remove the data from the"
" cache instead of going to the application to get a response."
msgstr ""

#: ../../book/http_cache.rst:892
msgid ""
"Here is how you can configure the Symfony reverse proxy to support the "
"``PURGE`` HTTP method::"
msgstr ""

#: ../../book/http_cache.rst:930
msgid ""
"You must protect the ``PURGE`` HTTP method somehow to avoid random people "
"purging your cached data."
msgstr ""

#: ../../book/http_cache.rst:933
msgid ""
"**Purge** instructs the cache to drop a resource in *all its variants* "
"(according to the ``Vary`` header, see above). An alternative to purging is "
"**refreshing** a content. Refreshing means that the caching proxy is "
"instructed to discard its local cache and fetch the content again. This way,"
" the new content is already available in the cache. The drawback of "
"refreshing is that variants are not invalidated."
msgstr ""

#: ../../book/http_cache.rst:940
msgid ""
"In many applications, the same content bit is used on various pages with "
"different URLs. More flexible concepts exist for those cases:"
msgstr ""

#: ../../book/http_cache.rst:943
msgid ""
"**Banning** invalidates responses matching regular expressions on the URL or"
" other criteria;"
msgstr ""

#: ../../book/http_cache.rst:945
msgid ""
"**Cache tagging** lets you add a tag for each content used in a response so "
"that you can invalidate all URLs containing a certain content."
msgstr ""

#: ../../book/http_cache.rst:955
msgid "Using Edge Side Includes"
msgstr ""

#: ../../book/http_cache.rst:957
msgid ""
"Gateway caches are a great way to make your website perform better. But they"
" have one limitation: they can only cache whole pages. If you can't cache "
"whole pages or if parts of a page has \"more\" dynamic parts, you are out of"
" luck. Fortunately, Symfony provides a solution for these cases, based on a "
"technology called `ESI`_, or Edge Side Includes. Akamai wrote this "
"specification almost 10 years ago and it allows specific parts of a page to "
"have a different caching strategy than the main page."
msgstr ""

#: ../../book/http_cache.rst:965
msgid ""
"The ESI specification describes tags you can embed in your pages to "
"communicate with the gateway cache. Only one tag is implemented in Symfony, "
"``include``, as this is the only useful one outside of Akamai context:"
msgstr ""

#: ../../book/http_cache.rst:985
msgid ""
"Notice from the example that each ESI tag has a fully-qualified URL. An ESI "
"tag represents a page fragment that can be fetched via the given URL."
msgstr ""

#: ../../book/http_cache.rst:989
msgid ""
"When a request is handled, the gateway cache fetches the entire page from "
"its cache or requests it from the backend application. If the response "
"contains one or more ESI tags, these are processed in the same way. In other"
" words, the gateway cache either retrieves the included page fragment from "
"its cache or requests the page fragment from the backend application again. "
"When all the ESI tags have been resolved, the gateway cache merges each into"
" the main page and sends the final content to the client."
msgstr ""

#: ../../book/http_cache.rst:997
msgid ""
"All of this happens transparently at the gateway cache level (i.e. outside "
"of your application). As you'll see, if you choose to take advantage of ESI "
"tags, Symfony makes the process of including them almost effortless."
msgstr ""

#: ../../book/http_cache.rst:1004
msgid "Using ESI in Symfony"
msgstr ""

#: ../../book/http_cache.rst:1006
msgid ""
"First, to use ESI, be sure to enable it in your application configuration:"
msgstr ""

#: ../../book/http_cache.rst:1043
msgid ""
"Now, suppose you have a page that is relatively static, except for a news "
"ticker at the bottom of the content. With ESI, you can cache the news ticker"
" independent of the rest of the page."
msgstr ""

#: ../../book/http_cache.rst:1064
msgid ""
"In this example, the full-page cache has a lifetime of ten minutes. Next, "
"include the news ticker in the template by embedding an action. This is done"
" via the ``render`` helper (See :ref:`templating-embedding-controller` for "
"more details)."
msgstr ""

#: ../../book/http_cache.rst:1069
msgid ""
"As the embedded content comes from another page (or controller for that "
"matter), Symfony uses the standard ``render`` helper to configure ESI tags:"
msgstr ""

#: ../../book/http_cache.rst:1109
msgid ""
"By using the ``esi`` renderer (via the ``render_esi`` Twig function), you "
"tell Symfony that the action should be rendered as an ESI tag. You might be "
"wondering why you would want to use a helper instead of just writing the ESI"
" tag yourself. That's because using a helper makes your application work "
"even if there is no gateway cache installed."
msgstr ""

#: ../../book/http_cache.rst:1117
msgid ""
"As you'll see below, the ``maxPerPage`` variable you pass is available as an"
" argument to your controller (i.e. ``$maxPerPage``). The variables passed "
"through ``render_esi`` also become part of the cache key so that you have "
"unique caches for each combination of variables and values."
msgstr ""

#: ../../book/http_cache.rst:1122
msgid ""
"When using the default ``render`` function (or setting the renderer to "
"``inline``), Symfony merges the included page content into the main one "
"before sending the response to the client. But if you use the ``esi`` "
"renderer (i.e. call ``render_esi``) *and* if Symfony detects that it's "
"talking to a gateway cache that supports ESI, it generates an ESI include "
"tag. But if there is no gateway cache or if it does not support ESI, Symfony"
" will just merge the included page content within the main one as it would "
"have done if you had used ``render``."
msgstr ""

#: ../../book/http_cache.rst:1133
msgid ""
"Symfony detects if a gateway cache supports ESI via another Akamai "
"specification that is supported out of the box by the Symfony reverse proxy."
msgstr ""

#: ../../book/http_cache.rst:1137
msgid ""
"The embedded action can now specify its own caching rules, entirely "
"independent of the master page."
msgstr ""

#: ../../book/http_cache.rst:1157
msgid ""
"With ESI, the full page cache will be valid for 600 seconds, but the news "
"component cache will only last for 60 seconds."
msgstr ""

#: ../../book/http_cache.rst:1160
msgid ""
"When using a controller reference, the ESI tag should reference the embedded"
" action as an accessible URL so the gateway cache can fetch it independently"
" of the rest of the page. Symfony takes care of generating a unique URL for "
"any controller reference and it is able to route them properly thanks to the"
" "
":class:`Symfony\\\\Component\\\\HttpKernel\\\\EventListener\\\\FragmentListener`"
" that must be enabled in your configuration:"
msgstr ""

#: ../../book/http_cache.rst:1202
msgid ""
"One great advantage of the ESI renderer is that you can make your "
"application as dynamic as needed and at the same time, hit the application "
"as little as possible."
msgstr ""

#: ../../book/http_cache.rst:1208
msgid ""
"The listener only responds to local IP addresses or :doc:`trusted proxies "
"</cookbook/request/load_balancer_reverse_proxy>`."
msgstr ""

#: ../../book/http_cache.rst:1213
msgid ""
"Once you start using ESI, remember to always use the ``s-maxage`` directive "
"instead of ``max-age``. As the browser only ever receives the aggregated "
"resource, it is not aware of the sub-components, and so it will obey the "
"``max-age`` directive and cache the entire page. And you don't want that."
msgstr ""

#: ../../book/http_cache.rst:1219
msgid "The ``render_esi`` helper supports two other useful options:"
msgstr ""

#: ../../book/http_cache.rst:1223
msgid "``alt``"
msgstr ""

#: ../../book/http_cache.rst:1222
msgid ""
"Used as the ``alt`` attribute on the ESI tag, which allows you to specify an"
" alternative URL to be used if the ``src`` cannot be found."
msgstr ""

#: ../../book/http_cache.rst:1228
msgid "``ignore_errors``"
msgstr ""

#: ../../book/http_cache.rst:1226
msgid ""
"If set to true, an ``onerror`` attribute will be added to the ESI with a "
"value of ``continue`` indicating that, in the event of a failure, the "
"gateway cache will simply remove the ESI tag silently."
msgstr ""

#: ../../book/http_cache.rst:1231
msgid "Summary"
msgstr ""

#: ../../book/http_cache.rst:1233
msgid ""
"Symfony was designed to follow the proven rules of the road: HTTP. Caching "
"is no exception. Mastering the Symfony cache system means becoming familiar "
"with the HTTP cache models and using them effectively. This means that, "
"instead of relying only on Symfony documentation and code examples, you have"
" access to a world of knowledge related to HTTP caching and gateway caches "
"such as Varnish."
msgstr ""

#: ../../book/http_cache.rst:1241
msgid "Learn more from the Cookbook"
msgstr ""

#: ../../book/http_cache.rst:1243
msgid ":doc:`/cookbook/cache/varnish`"
msgstr ""

#: ../../book/http_cache.rst:1 ../../book/http_cache.rst:64
#: ../../book/http_cache.rst:64 ../../book/http_cache.rst:64
#: ../../book/http_cache.rst:90 ../../book/http_cache.rst:128
#: ../../book/http_cache.rst:273 ../../book/http_cache.rst:308
#: ../../book/http_cache.rst:374 ../../book/http_cache.rst:463
#: ../../book/http_cache.rst:477 ../../book/http_cache.rst:512
#: ../../book/http_cache.rst:540 ../../book/http_cache.rst:571
#: ../../book/http_cache.rst:632 ../../book/http_cache.rst:694
#: ../../book/http_cache.rst:755 ../../book/http_cache.rst:815
#: ../../book/http_cache.rst:843 ../../book/http_cache.rst:948
msgid "Cache"
msgstr ""

#: ../../book/http_cache.rst:64
msgid "Proxy"
msgstr ""

#: ../../book/http_cache.rst:64
msgid "Reverse proxy"
msgstr ""

#: ../../book/http_cache.rst:64
msgid "Gateway"
msgstr ""

#: ../../book/http_cache.rst:90
msgid "Types of"
msgstr ""

#: ../../book/http_cache.rst:128
msgid "Symfony reverse proxy"
msgstr ""

#: ../../book/http_cache.rst:273 ../../book/http_cache.rst:694
msgid "HTTP"
msgstr ""

#: ../../book/http_cache.rst:308 ../../book/http_cache.rst:512
msgid "Cache-Control header"
msgstr ""

#: ../../book/http_cache.rst:308 ../../book/http_cache.rst:477
#: ../../book/http_cache.rst:512 ../../book/http_cache.rst:571
#: ../../book/http_cache.rst:632 ../../book/http_cache.rst:755
msgid "HTTP headers"
msgstr ""

#: ../../book/http_cache.rst:308 ../../book/http_cache.rst:512
msgid "Cache-Control"
msgstr ""

#: ../../book/http_cache.rst:374
msgid "Safe methods"
msgstr ""

#: ../../book/http_cache.rst:463
msgid "HTTP expiration"
msgstr ""

#: ../../book/http_cache.rst:477
msgid "Expires header"
msgstr ""

#: ../../book/http_cache.rst:477
msgid "Expires"
msgstr ""

#: ../../book/http_cache.rst:571
msgid "Etag header"
msgstr ""

#: ../../book/http_cache.rst:571
msgid "Etag"
msgstr ""

#: ../../book/http_cache.rst:632
msgid "Last-Modified header"
msgstr ""

#: ../../book/http_cache.rst:632
msgid "Last-Modified"
msgstr ""

#: ../../book/http_cache.rst:694
msgid "Conditional get"
msgstr ""

#: ../../book/http_cache.rst:694
msgid "304"
msgstr ""

#: ../../book/http_cache.rst:755 ../../book/http_cache.rst:755
msgid "Vary"
msgstr ""

#: ../../book/http_cache.rst:815
msgid "Configuration"
msgstr ""

#: ../../book/http_cache.rst:843
msgid "Invalidation"
msgstr ""

#: ../../book/http_cache.rst:948 ../../book/http_cache.rst:948
msgid "ESI"
msgstr ""
