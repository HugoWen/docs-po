# 
msgid ""
msgstr ""
"Project-Id-Version: Symfony Framework Documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-03-24 10:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../cookbook/doctrine/resolve_target_entity.rst:6
msgid "How to Define Relationships with Abstract Classes and Interfaces"
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:8
msgid ""
"One of the goals of bundles is to create discreet bundles of functionality "
"that do not have many (if any) dependencies, allowing you to use that "
"functionality in other applications without including unnecessary items."
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:12
msgid ""
"Doctrine 2.2 includes a new utility called the "
"``ResolveTargetEntityListener``, that functions by intercepting certain "
"calls inside Doctrine and rewriting ``targetEntity`` parameters in your "
"metadata mapping at runtime. It means that in your bundle you are able to "
"use an interface or abstract class in your mappings and expect correct "
"mapping to a concrete entity at runtime."
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:18
msgid ""
"This functionality allows you to define relationships between different "
"entities without making them hard dependencies."
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:22
msgid "Background"
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:24
msgid ""
"Suppose you have an `InvoiceBundle` which provides invoicing functionality "
"and a `CustomerBundle` that contains customer management tools. You want to "
"keep these separated, because they can be used in other systems without each"
" other, but for your application you want to use them together."
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:29
msgid ""
"In this case, you have an ``Invoice`` entity with a relationship to a non-"
"existent object, an ``InvoiceSubjectInterface``. The goal is to get the "
"``ResolveTargetEntityListener`` to replace any mention of the interface with"
" a real object that implements that interface."
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:35
msgid "Set up"
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:37
msgid ""
"This article uses the following two basic entities (which are incomplete for"
" brevity) to explain how to set up and use the "
"``ResolveTargetEntityListener``."
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:40
msgid "A Customer entity::"
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:60
msgid "An Invoice entity::"
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:84
msgid "An InvoiceSubjectInterface::"
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:108
msgid ""
"Next, you need to configure the listener, which tells the DoctrineBundle "
"about the replacement:"
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:153
msgid "Final Thoughts"
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:155
msgid ""
"With the ``ResolveTargetEntityListener``, you are able to decouple your "
"bundles, keeping them usable by themselves, but still being able to define "
"relationships between different objects. By using this method, your bundles "
"will end up being easier to maintain independently."
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:1
#: ../../cookbook/doctrine/resolve_target_entity.rst:1
msgid "Doctrine"
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:1
msgid "Resolving target entities"
msgstr ""

#: ../../cookbook/doctrine/resolve_target_entity.rst:1
msgid "Define relationships with abstract classes and interfaces"
msgstr ""
