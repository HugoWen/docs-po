# 
msgid ""
msgstr ""
"Project-Id-Version: Symfony Framework Documentation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-03-24 10:10+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../cookbook/form/form_collections.rst:5
msgid "How to Embed a Collection of Forms"
msgstr ""

#: ../../cookbook/form/form_collections.rst:7
msgid ""
"In this entry, you'll learn how to create a form that embeds a collection of"
" many other forms. This could be useful, for example, if you had a ``Task`` "
"class and you wanted to edit/create/remove many ``Tag`` objects related to "
"that Task, right inside the same form."
msgstr ""

#: ../../cookbook/form/form_collections.rst:14
msgid ""
"In this entry, it's loosely assumed that you're using Doctrine as your "
"database store. But if you're not using Doctrine (e.g. Propel or just a "
"database connection), it's all very similar. There are only a few parts of "
"this tutorial that really care about \"persistence\"."
msgstr ""

#: ../../cookbook/form/form_collections.rst:19
msgid ""
"If you *are* using Doctrine, you'll need to add the Doctrine metadata, "
"including the ``ManyToMany`` association mapping definition on the Task's "
"``tags`` property."
msgstr ""

#: ../../cookbook/form/form_collections.rst:23
msgid ""
"First, suppose that each ``Task`` belongs to multiple ``Tag`` objects. Start"
" by creating a simple ``Task`` class::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:60
msgid ""
"The ``ArrayCollection`` is specific to Doctrine and is basically the same as"
" using an ``array`` (but it must be an ``ArrayCollection`` if you're using "
"Doctrine)."
msgstr ""

#: ../../cookbook/form/form_collections.rst:64
msgid ""
"Now, create a ``Tag`` class. As you saw above, a ``Task`` can have many "
"``Tag`` objects::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:77
msgid ""
"The ``name`` property is public here, but it can just as easily be protected"
" or private (but then it would need ``getName`` and ``setName`` methods)."
msgstr ""

#: ../../cookbook/form/form_collections.rst:80
msgid ""
"Then, create a form class so that a ``Tag`` object can be modified by the "
"user::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:109
msgid ""
"With this, you have enough to render a tag form by itself. But since the end"
" goal is to allow the tags of a ``Task`` to be modified right inside the "
"task form itself, create a form for the ``Task`` class."
msgstr ""

#: ../../cookbook/form/form_collections.rst:113
msgid ""
"Notice that you embed a collection of ``TagType`` forms using the "
":doc:`collection </reference/forms/types/collection>` field type::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:145
msgid ""
"In your controller, you'll now initialize a new instance of ``TaskType``::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:186
msgid ""
"The corresponding template is now able to render both the ``description`` "
"field for the task form as well as all the ``TagType`` forms for any tags "
"that are already related to this ``Task``. In the above controller, I added "
"some dummy code so that you can see this in action (since a ``Task`` has "
"zero tags when first created)."
msgstr ""

#: ../../cookbook/form/form_collections.rst:235
msgid ""
"When the user submits the form, the submitted data for the ``tags`` field "
"are used to construct an ``ArrayCollection`` of ``Tag`` objects, which is "
"then set on the ``tag`` field of the ``Task`` instance."
msgstr ""

#: ../../cookbook/form/form_collections.rst:239
msgid ""
"The ``tags`` collection is accessible naturally via ``$task->getTags()`` and"
" can be persisted to the database or used however you need."
msgstr ""

#: ../../cookbook/form/form_collections.rst:242
msgid ""
"So far, this works great, but this doesn't allow you to dynamically add new "
"tags or delete existing tags. So, while editing existing tags will work "
"great, your user can't actually add any new tags yet."
msgstr ""

#: ../../cookbook/form/form_collections.rst:248
msgid ""
"In this entry, you embed only one collection, but you are not limited to "
"this. You can also embed nested collection as many levels down as you like. "
"But if you use Xdebug in your development setup, you may receive a ``Maximum"
" function nesting level of '100' reached, aborting!`` error. This is due to "
"the ``xdebug.max_nesting_level`` PHP setting, which defaults to ``100``."
msgstr ""

#: ../../cookbook/form/form_collections.rst:255
msgid ""
"This directive limits recursion to 100 calls which may not be enough for "
"rendering the form in the template if you render the whole form at once (e.g"
" ``form_widget(form)``). To fix this you can set this directive to a higher "
"value (either via a ``php.ini`` file or via :phpfunction:`ini_set`, for "
"example in ``app/autoload.php``) or render each form field by hand using "
"``form_row``."
msgstr ""

#: ../../cookbook/form/form_collections.rst:265
msgid "Allowing \"new\" Tags with the \"Prototype\""
msgstr ""

#: ../../cookbook/form/form_collections.rst:267
msgid ""
"Allowing the user to dynamically add new tags means that you'll need to use "
"some JavaScript. Previously you added two tags to your form in the "
"controller. Now let the user add as many tag forms as they need directly in "
"the browser. This will be done through a bit of JavaScript."
msgstr ""

#: ../../cookbook/form/form_collections.rst:272
msgid ""
"The first thing you need to do is to let the form collection know that it "
"will receive an unknown number of tags. So far you've added two tags and the"
" form type expects to receive exactly two, otherwise an error will be "
"thrown: ``This form should not contain extra fields``. To make this "
"flexible, add the ``allow_add`` option to your collection field::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:293
msgid ""
"In addition to telling the field to accept any number of submitted objects, "
"the ``allow_add`` also makes a *\"prototype\"* variable available to you. "
"This \"prototype\" is a little \"template\" that contains all the HTML to be"
" able to render any new \"tag\" forms. To render it, make the following "
"change to your template:"
msgstr ""

#: ../../cookbook/form/form_collections.rst:316
msgid ""
"If you render your whole \"tags\" sub-form at once (e.g. "
"``form_row(form.tags)``), then the prototype is automatically available on "
"the outer ``div`` as the ``data-prototype`` attribute, similar to what you "
"see above."
msgstr ""

#: ../../cookbook/form/form_collections.rst:322
msgid ""
"The ``form.tags.vars.prototype`` is a form element that looks and feels just"
" like the individual ``form_widget(tag)`` elements inside your ``for`` loop."
" This means that you can call ``form_widget``, ``form_row`` or "
"``form_label`` on it. You could even choose to render only one of its fields"
" (e.g. the ``name`` field):"
msgstr ""

#: ../../cookbook/form/form_collections.rst:332
msgid "On the rendered page, the result will look something like this:"
msgstr ""

#: ../../cookbook/form/form_collections.rst:338
msgid ""
"The goal of this section will be to use JavaScript to read this attribute "
"and dynamically add new tag forms when the user clicks a \"Add a tag\" link."
" To make things simple, this example uses jQuery and assumes you have it "
"included somewhere on your page."
msgstr ""

#: ../../cookbook/form/form_collections.rst:343
msgid ""
"Add a ``script`` tag somewhere on your page so you can start writing some "
"JavaScript."
msgstr ""

#: ../../cookbook/form/form_collections.rst:345
msgid ""
"First, add a link to the bottom of the \"tags\" list via JavaScript. Second,"
" bind to the \"click\" event of that link so you can add a new tag form "
"(``addTagForm`` will be show next):"
msgstr ""

#: ../../cookbook/form/form_collections.rst:377
msgid ""
"The ``addTagForm`` function's job will be to use the ``data-prototype`` "
"attribute to dynamically add a new form when this link is clicked. The "
"``data-prototype`` HTML contains the tag ``text`` input element with a name "
"of ``task[tags][__name__][name]`` and id of ``task_tags___name___name``. The"
" ``__name__`` is a little \"placeholder\", which you'll replace with a "
"unique, incrementing number (e.g. ``task[tags][3][name]``)."
msgstr ""

#: ../../cookbook/form/form_collections.rst:383
msgid ""
"The actual code needed to make this all work can vary quite a bit, but "
"here's one example:"
msgstr ""

#: ../../cookbook/form/form_collections.rst:409
msgid ""
"It is better to separate your JavaScript in real JavaScript files than to "
"write it inside the HTML as is done here."
msgstr ""

#: ../../cookbook/form/form_collections.rst:412
msgid ""
"Now, each time a user clicks the ``Add a tag`` link, a new sub form will "
"appear on the page. When the form is submitted, any new tag forms will be "
"converted into new ``Tag`` objects and added to the ``tags`` property of the"
" ``Task`` object."
msgstr ""

#: ../../cookbook/form/form_collections.rst:418
msgid "You can find a working example in this `JSFiddle`_."
msgstr ""

#: ../../cookbook/form/form_collections.rst:420
msgid ""
"To make handling these new tags easier, add an \"adder\" and a \"remover\" "
"method for the tags in the ``Task`` class::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:442
msgid ""
"Next, add a ``by_reference`` option to the ``tags`` field and set it to "
"``false``::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:457
msgid ""
"With these two changes, when the form is submitted, each new ``Tag`` object "
"is added to the ``Task`` class by calling the ``addTag`` method. Before this"
" change, they were added internally by the form by calling "
"``$task->getTags()->add($tag)``. That was just fine, but forcing the use of "
"the \"adder\" method makes handling these new ``Tag`` objects easier "
"(especially if you're using Doctrine, which you will learn about next!)."
msgstr ""

#: ../../cookbook/form/form_collections.rst:466
msgid ""
"You have to create **both** ``addTag`` and ``removeTag`` methods, otherwise "
"the form will still use ``setTag`` even if ``by_reference`` is ``false``. "
"You'll learn more about the ``removeTag`` method later in this article."
msgstr ""

#: ../../cookbook/form/form_collections.rst:0
msgid "Doctrine: Cascading Relations and saving the \"Inverse\" side"
msgstr ""

#: ../../cookbook/form/form_collections.rst:472
msgid ""
"To save the new tags with Doctrine, you need to consider a couple more "
"things. First, unless you iterate over all of the new ``Tag`` objects and "
"call ``$em->persist($tag)`` on each, you'll receive an error from Doctrine:"
msgstr ""

#: ../../cookbook/form/form_collections.rst:477
msgid ""
"A new entity was found through the relationship "
"``Acme\\TaskBundle\\Entity\\Task#tags`` that was not configured to cascade "
"persist operations for entity..."
msgstr ""

#: ../../cookbook/form/form_collections.rst:481
msgid ""
"To fix this, you may choose to \"cascade\" the persist operation "
"automatically from the ``Task`` object to any related tags. To do this, add "
"the ``cascade`` option to your ``ManyToMany`` metadata:"
msgstr ""

#: ../../cookbook/form/form_collections.rst:527
msgid ""
"A second potential issue deals with the `Owning Side and Inverse Side`_ of "
"Doctrine relationships. In this example, if the \"owning\" side of the "
"relationship is \"Task\", then persistence will work fine as the tags are "
"properly added to the Task. However, if the owning side is on \"Tag\", then "
"you'll need to do a little bit more work to ensure that the correct side of "
"the relationship is modified."
msgstr ""

#: ../../cookbook/form/form_collections.rst:534
msgid ""
"The trick is to make sure that the single \"Task\" is set on each \"Tag\". "
"One easy way to do this is to add some extra logic to ``addTag()``, which is"
" called by the form type since ``by_reference`` is set to ``false``::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:549
msgid "Inside ``Tag``, just make sure you have an ``addTask`` method::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:561
msgid ""
"If you have a one-to-many relationship, then the workaround is similar, "
"except that you can simply call ``setTask`` from inside ``addTag``."
msgstr ""

#: ../../cookbook/form/form_collections.rst:567
msgid "Allowing Tags to be Removed"
msgstr ""

#: ../../cookbook/form/form_collections.rst:569
msgid ""
"The next step is to allow the deletion of a particular item in the "
"collection. The solution is similar to allowing tags to be added."
msgstr ""

#: ../../cookbook/form/form_collections.rst:572
msgid "Start by adding the ``allow_delete`` option in the form Type::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:587
msgid ""
"Now, you need to put some code into the ``removeTag`` method of ``Task``::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:603
msgid "Template Modifications"
msgstr ""

#: ../../cookbook/form/form_collections.rst:605
msgid ""
"The ``allow_delete`` option has one consequence: if an item of a collection "
"isn't sent on submission, the related data is removed from the collection on"
" the server. The solution is thus to remove the form element from the DOM."
msgstr ""

#: ../../cookbook/form/form_collections.rst:609
msgid "First, add a \"delete this tag\" link to each tag form:"
msgstr ""

#: ../../cookbook/form/form_collections.rst:632
msgid "The ``addTagFormDeleteLink`` function will look something like this:"
msgstr ""

#: ../../cookbook/form/form_collections.rst:649
msgid ""
"When a tag form is removed from the DOM and submitted, the removed ``Tag`` "
"object will not be included in the collection passed to ``setTags``. "
"Depending on your persistence layer, this may or may not be enough to "
"actually remove the relationship between the removed ``Tag`` and ``Task`` "
"object."
msgstr ""

#: ../../cookbook/form/form_collections.rst:0
msgid "Doctrine: Ensuring the database persistence"
msgstr ""

#: ../../cookbook/form/form_collections.rst:656
msgid ""
"When removing objects in this way, you may need to do a little bit more work"
" to ensure that the relationship between the ``Task`` and the removed "
"``Tag`` is properly removed."
msgstr ""

#: ../../cookbook/form/form_collections.rst:660
msgid ""
"In Doctrine, you have two sides of the relationship: the owning side and the"
" inverse side. Normally in this case you'll have a many-to-many relationship"
" and the deleted tags will disappear and persist correctly (adding new tags "
"also works effortlessly)."
msgstr ""

#: ../../cookbook/form/form_collections.rst:665
msgid ""
"But if you have a one-to-many relationship or a many-to-many relationship "
"with a ``mappedBy`` on the Task entity (meaning Task is the \"inverse\" "
"side), you'll need to do more work for the removed tags to persist "
"correctly."
msgstr ""

#: ../../cookbook/form/form_collections.rst:669
msgid ""
"In this case, you can modify the controller to remove the relationship on "
"the removed tag. This assumes that you have some ``editAction`` which is "
"handling the \"update\" of your Task::"
msgstr ""

#: ../../cookbook/form/form_collections.rst:726
msgid ""
"As you can see, adding and removing the elements correctly can be tricky. "
"Unless you have a many-to-many relationship where Task is the \"owning\" "
"side, you'll need to do extra work to make sure that the relationship is "
"properly updated (whether you're adding new tags or removing existing tags) "
"on each Tag object itself."
msgstr ""

#: ../../cookbook/form/form_collections.rst:1
msgid "Form"
msgstr ""

#: ../../cookbook/form/form_collections.rst:1
msgid "Embed collection of forms"
msgstr ""
